name: Deploy Applications

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  application:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      KUBE_NAMESPACE: ${{ inputs.environment == 'prod' && secrets.KUBE_NAMESPACE_PROD || inputs.environment == 'staging' && secrets.KUBE_NAMESPACE_STAGING || secrets.KUBE_NAMESPACE_DEV }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.AWS_ROLE_ARN_PROD || inputs.environment == 'staging' && secrets.AWS_ROLE_ARN_STAGING || secrets.AWS_ROLE_ARN_DEV }}
          aws-region: us-east-1

      - name: Set up Terraform (for outputs)
        uses: hashicorp/setup-terraform@v2

      - name: Extract Terraform Outputs
        run: |
          terraform init
          echo "MYSQL_ENDPOINT=$(terraform output -raw mysql_instance_endpoint)" >> $GITHUB_ENV
          echo "POSTGRES_ENDPOINT=$(terraform output -raw postgres_instance_endpoint)" >> $GITHUB_ENV
          echo "REDIS_ENDPOINT=$(terraform output -raw redis_cluster_endpoint)" >> $GITHUB_ENV
          echo "REDIS_PORT=$(terraform output -raw redis_cluster_port)" >> $GITHUB_ENV
          echo "DYNAMODB_TABLE_NAME=$(terraform output -raw dynamodb_table_name)" >> $GITHUB_ENV
        working-directory: ./environments/${{ inputs.environment }}

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Update Helm values.yaml
        run: |
          yq e '.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/catalog/values.yaml
          yq e '.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/order/values.yaml
          yq e '.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/checkout/values.yaml
          yq e '.redisPort = env(REDIS_PORT)' -i helm/checkout/values.yaml
          yq e '.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/cart/values.yaml
          yq e '.microservices.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisPort = env(REDIS_PORT)' -i helm/ui/values.yaml
          yq e '.microservices.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/ui/values.yaml

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        run: |
          terraform init
          aws eks update-kubeconfig --region us-east-1 --name $(terraform output -raw eks_cluster_name)
        working-directory: ./environments/${{ inputs.environment }}

      - name: Create namespace
        run: |
          kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets-system \
            --create-namespace

      - name: Install AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          terraform init
          LB_ROLE_ARN=$(terraform output -raw aws_load_balancer_controller_role_arn)
          CLUSTER_NAME=$(terraform output -raw eks_cluster_name)
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=$LB_ROLE_ARN
        working-directory: ./environments/${{ inputs.environment }}

      - name: Setup External Secrets Store
        run: |
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: aws-secrets-store
          spec:
            provider:
              aws:
                service: SecretsManager
                region: us-east-1
                auth:
                  jwt:
                    serviceAccountRef:
                      name: external-secrets-sa
                      namespace: external-secrets-system
          EOF

      - name: Deploy External Secrets
        run: |
          terraform init
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-postgres-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-postgres-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $(terraform output -raw postgres_secret_name)
          ---
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-mysql-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-mysql-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $(terraform output -raw mysql_secret_name)
          EOF
        working-directory: ./environments/${{ inputs.environment }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install cart helm/cart --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install catalog helm/catalog --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install checkout helm/checkout --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install order helm/order --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install ui helm/ui --namespace $KUBE_NAMESPACE --create-namespace