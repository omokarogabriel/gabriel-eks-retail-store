name: Deploy Applications

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  application:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      KUBE_NAMESPACE: ${{ inputs.environment == 'prod' && secrets.KUBE_NAMESPACE_PROD || inputs.environment == 'staging' && secrets.KUBE_NAMESPACE_STAGING || secrets.KUBE_NAMESPACE_DEV }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.AWS_ROLE_ARN_PROD || inputs.environment == 'staging' && secrets.AWS_ROLE_ARN_STAGING || secrets.AWS_ROLE_ARN_DEV }}
          aws-region: eu-north-1

      # - name: Set up Terraform (for outputs)
      #   uses: hashicorp/setup-terraform@v2

      - name: Set Infrastructure Endpoints
        run: |
          echo "MYSQL_ENDPOINT=dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306" >> $GITHUB_ENV
          echo "POSTGRES_ENDPOINT=dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432" >> $GITHUB_ENV
          echo "REDIS_ENDPOINT=retail-redis.44wxnl.0001.eun1.cache.amazonaws.com" >> $GITHUB_ENV
          echo "REDIS_PORT=6379" >> $GITHUB_ENV
          echo "DYNAMODB_TABLE_NAME=dev-retail-dynamodb" >> $GITHUB_ENV
          echo "Infrastructure endpoints set:"
          echo "MySQL: dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306"
          echo "Postgres: dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432"
          echo "Redis: retail-redis.44wxnl.0001.eun1.cache.amazonaws.com:6379"
          echo "DynamoDB: dev-retail-dynamodb"

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Update Helm values.yaml
        run: |
          yq e '.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/catalog/values.yaml
          yq e '.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/order/values.yaml
          yq e '.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/checkout/values.yaml
          yq e '.redisPort = env(REDIS_PORT)' -i helm/checkout/values.yaml
          yq e '.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/cart/values.yaml
          yq e '.microservices.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisPort = env(REDIS_PORT)' -i helm/ui/values.yaml
          yq e '.microservices.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/ui/values.yaml

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        run: |
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          echo "Checking if cluster exists..."
          aws eks describe-cluster --region eu-north-1 --name $CLUSTER_NAME
          echo "Updating kubeconfig..."
          aws eks update-kubeconfig --region eu-north-1 --name $CLUSTER_NAME --alias $CLUSTER_NAME
          echo "Configured kubectl for cluster: $CLUSTER_NAME"

      - name: Configure EKS access
        run: |
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          GITHUB_ROLE_ARN="arn:aws:iam::438465156402:role/dev-vpc-retail-store-github-actions-role"
          NODE_ROLE_ARN="arn:aws:iam::438465156402:role/dev-vpc-retail-store-eks-node-role"
          echo "Configuring EKS cluster access for role: $GITHUB_ROLE_ARN"
          
          # Try access entries first (newer EKS clusters)
          echo "Attempting access entry method..."
          ACCESS_ENTRY_SUCCESS=false
          
          if aws eks create-access-entry \
            --cluster-name $CLUSTER_NAME \
            --principal-arn $GITHUB_ROLE_ARN \
            --type STANDARD \
            --region eu-north-1 2>/dev/null; then
            echo "Access entry created"
            if aws eks associate-access-policy \
              --cluster-name $CLUSTER_NAME \
              --principal-arn $GITHUB_ROLE_ARN \
              --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy \
              --access-scope type=cluster \
              --region eu-north-1 2>/dev/null; then
              echo "Access entry method successful"
              ACCESS_ENTRY_SUCCESS=true
            fi
          fi
          
          if [ "$ACCESS_ENTRY_SUCCESS" = "false" ]; then
            echo "Access entry method failed, trying aws-auth ConfigMap..."
            
            # Create or update aws-auth ConfigMap
            cat <<EOF | kubectl apply -f - || echo "ConfigMap creation failed"
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: aws-auth
            namespace: kube-system
          data:
            mapRoles: |
              - rolearn: $NODE_ROLE_ARN
                username: system:node:{{EC2PrivateDNSName}}
                groups:
                  - system:bootstrappers
                  - system:nodes
              - rolearn: $GITHUB_ROLE_ARN
                username: github-actions
                groups:
                  - system:masters
          EOF
          fi
          
          echo "Waiting for access to propagate..."
          sleep 60

      - name: Test cluster connection
        run: |
          echo "Testing kubectl connection..."
          for i in {1..5}; do
            if kubectl cluster-info && kubectl get nodes && kubectl get namespaces; then
              echo "Cluster connection successful"
              break
            else
              echo "Attempt $i failed, retrying in 30 seconds..."
              sleep 30
            fi
          done

      - name: Create namespace
        run: |
          echo "Creating namespace: $KUBE_NAMESPACE"
          kubectl create namespace $KUBE_NAMESPACE || echo "Namespace may already exist"
          kubectl get namespace $KUBE_NAMESPACE
          echo "Namespace $KUBE_NAMESPACE is ready"

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets-system \
            --create-namespace \
            --wait \
            --timeout=10m

      - name: Install AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          LB_ROLE_ARN='arn:aws:iam::438465156402:role/dev-vpc-retail-store-aws-load-balancer-controller'
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          
          # Wait for external-secrets to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets -n external-secrets-system || echo "External secrets not ready, continuing..."
          
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=$LB_ROLE_ARN \
            --wait \
            --timeout=10m
          echo "Installed Load Balancer Controller with role: $LB_ROLE_ARN"

      - name: Setup External Secrets Store
        run: |
          # Wait for external-secrets operator to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets -n external-secrets-system
          
          cat <<EOF | kubectl apply -f -
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: aws-secrets-store
          spec:
            provider:
              aws:
                service: SecretsManager
                region: eu-north-1
                auth:
                  jwt:
                    serviceAccountRef:
                      name: external-secrets-sa
                      namespace: external-secrets-system
          EOF
          
          # Verify the ClusterSecretStore is ready
          kubectl wait --for=condition=Ready --timeout=300s clustersecretstore/aws-secrets-store || echo "ClusterSecretStore not ready, continuing..."

      - name: Deploy External Secrets
        run: |
          POSTGRES_SECRET='dev-vpc-retail-store-postgres-password'
          MYSQL_SECRET='dev-vpc-retail-store-mysql-password'
          
          cat <<EOF | kubectl apply -f -
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-postgres-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-postgres-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $POSTGRES_SECRET
          ---
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-mysql-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-mysql-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $MYSQL_SECRET
          EOF
          
          echo "Deployed External Secrets for: $POSTGRES_SECRET, $MYSQL_SECRET"
          
          # Wait for secrets to be created
          kubectl wait --for=condition=Ready --timeout=300s externalsecret/app-postgres-db-secret -n $KUBE_NAMESPACE || echo "Postgres secret not ready"
          kubectl wait --for=condition=Ready --timeout=300s externalsecret/app-mysql-db-secret -n $KUBE_NAMESPACE || echo "MySQL secret not ready"

      - name: Deploy with Helm
        run: |
          echo "Deploying microservices..."
          
          # Deploy each service with proper wait and timeout
          helm upgrade --install cart helm/cart \
            --namespace $KUBE_NAMESPACE \
            --create-namespace \
            --wait \
            --timeout=10m || echo "Cart deployment failed, continuing..."
          
          helm upgrade --install catalog helm/catalog \
            --namespace $KUBE_NAMESPACE \
            --create-namespace \
            --wait \
            --timeout=10m || echo "Catalog deployment failed, continuing..."
          
          helm upgrade --install checkout helm/checkout \
            --namespace $KUBE_NAMESPACE \
            --create-namespace \
            --wait \
            --timeout=10m || echo "Checkout deployment failed, continuing..."
          
          helm upgrade --install order helm/order \
            --namespace $KUBE_NAMESPACE \
            --create-namespace \
            --wait \
            --timeout=10m || echo "Order deployment failed, continuing..."
          
          helm upgrade --install ui helm/ui \
            --namespace $KUBE_NAMESPACE \
            --create-namespace \
            --wait \
            --timeout=10m || echo "UI deployment failed, continuing..."
          
          echo "Deployment completed. Checking pod status..."
          kubectl get pods -n $KUBE_NAMESPACE || echo "Failed to get pod status"