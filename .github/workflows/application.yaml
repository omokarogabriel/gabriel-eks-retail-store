name: Deploy Applications

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  application:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      KUBE_NAMESPACE: ${{ inputs.environment == 'prod' && secrets.KUBE_NAMESPACE_PROD || inputs.environment == 'staging' && secrets.KUBE_NAMESPACE_STAGING || secrets.KUBE_NAMESPACE_DEV }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.AWS_ROLE_ARN_PROD || inputs.environment == 'staging' && secrets.AWS_ROLE_ARN_STAGING || secrets.AWS_ROLE_ARN_DEV }}
          aws-region: eu-north-1

      - name: Set up Terraform (for outputs)
        uses: hashicorp/setup-terraform@v2

      - name: Set Infrastructure Endpoints
        run: |
          echo "MYSQL_ENDPOINT=dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306" >> $GITHUB_ENV
          echo "POSTGRES_ENDPOINT=dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432" >> $GITHUB_ENV
          echo "REDIS_ENDPOINT=retail-redis.44wxnl.0001.eun1.cache.amazonaws.com" >> $GITHUB_ENV
          echo "REDIS_PORT=6379" >> $GITHUB_ENV
          echo "DYNAMODB_TABLE_NAME=dev-retail-dynamodb" >> $GITHUB_ENV
          echo "Infrastructure endpoints set:"
          echo "MySQL: dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306"
          echo "Postgres: dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432"
          echo "Redis: retail-redis.44wxnl.0001.eun1.cache.amazonaws.com:6379"
          echo "DynamoDB: dev-retail-dynamodb"

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Update Helm values.yaml
        run: |
          yq e '.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/catalog/values.yaml
          yq e '.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/order/values.yaml
          yq e '.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/checkout/values.yaml
          yq e '.redisPort = env(REDIS_PORT)' -i helm/checkout/values.yaml
          yq e '.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/cart/values.yaml
          yq e '.microservices.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisPort = env(REDIS_PORT)' -i helm/ui/values.yaml
          yq e '.microservices.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/ui/values.yaml

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        run: |
          CLUSTER_NAME=$(terraform output -raw eks_cluster_name || echo 'dev-vpc-retail-store-eks-cluster')
          aws eks update-kubeconfig --region eu-north-1 --name $CLUSTER_NAME
          echo "Configured kubectl for cluster: $CLUSTER_NAME"
        working-directory: ./environments/${{ inputs.environment }}

      - name: Create namespace
        run: |
          kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets-system \
            --create-namespace

      - name: Install AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          LB_ROLE_ARN=$(terraform output -raw aws_load_balancer_controller_role_arn || echo 'arn:aws:iam::438465156402:role/dev-vpc-retail-store-aws-load-balancer-controller')
          CLUSTER_NAME=$(terraform output -raw eks_cluster_name || echo 'dev-vpc-retail-store-eks-cluster')
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=$LB_ROLE_ARN
          echo "Installed Load Balancer Controller with role: $LB_ROLE_ARN"
        working-directory: ./environments/${{ inputs.environment }}

      - name: Setup External Secrets Store
        run: |
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: aws-secrets-store
          spec:
            provider:
              aws:
                service: SecretsManager
                region: eu-north-1
                auth:
                  jwt:
                    serviceAccountRef:
                      name: external-secrets-sa
                      namespace: external-secrets-system
          EOF

      - name: Deploy External Secrets
        run: |
          POSTGRES_SECRET=$(terraform output -raw postgres_secret_name || echo 'dev-vpc-retail-store-postgres-password')
          MYSQL_SECRET=$(terraform output -raw mysql_secret_name || echo 'dev-vpc-retail-store-mysql-password')
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-postgres-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-postgres-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $POSTGRES_SECRET
          ---
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-mysql-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-mysql-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $MYSQL_SECRET
          EOF
          echo "Deployed External Secrets for: $POSTGRES_SECRET, $MYSQL_SECRET"
        working-directory: ./environments/${{ inputs.environment }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install cart helm/cart --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install catalog helm/catalog --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install checkout helm/checkout --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install order helm/order --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install ui helm/ui --namespace $KUBE_NAMESPACE --create-namespace