name: Deploy Applications

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  application:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      KUBE_NAMESPACE: ${{ inputs.environment == 'prod' && secrets.KUBE_NAMESPACE_PROD || inputs.environment == 'staging' && secrets.KUBE_NAMESPACE_STAGING || secrets.KUBE_NAMESPACE_DEV }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.AWS_ROLE_ARN_PROD || inputs.environment == 'staging' && secrets.AWS_ROLE_ARN_STAGING || secrets.AWS_ROLE_ARN_DEV }}
          aws-region: eu-north-1

      # - name: Set up Terraform (for outputs)
      #   uses: hashicorp/setup-terraform@v2

      - name: Set Infrastructure Endpoints
        run: |
          echo "MYSQL_ENDPOINT=dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306" >> $GITHUB_ENV
          echo "POSTGRES_ENDPOINT=dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432" >> $GITHUB_ENV
          echo "REDIS_ENDPOINT=retail-redis.44wxnl.0001.eun1.cache.amazonaws.com" >> $GITHUB_ENV
          echo "REDIS_PORT=6379" >> $GITHUB_ENV
          echo "DYNAMODB_TABLE_NAME=dev-retail-dynamodb" >> $GITHUB_ENV
          echo "Infrastructure endpoints set:"
          echo "MySQL: dev-vpc-retail-store-mysql-database.c74240umo210.eu-north-1.rds.amazonaws.com:3306"
          echo "Postgres: dev-vpc-retail-store-postgres-database.c74240umo210.eu-north-1.rds.amazonaws.com:5432"
          echo "Redis: retail-redis.44wxnl.0001.eun1.cache.amazonaws.com:6379"
          echo "DynamoDB: dev-retail-dynamodb"

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Update Helm values.yaml
        run: |
          yq e '.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/catalog/values.yaml
          yq e '.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/order/values.yaml
          yq e '.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/checkout/values.yaml
          yq e '.redisPort = env(REDIS_PORT)' -i helm/checkout/values.yaml
          yq e '.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/cart/values.yaml
          yq e '.microservices.mysqlEndpoint = env(MYSQL_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.postgresEndpoint = env(POSTGRES_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisEndpoint = env(REDIS_ENDPOINT)' -i helm/ui/values.yaml
          yq e '.microservices.redisPort = env(REDIS_PORT)' -i helm/ui/values.yaml
          yq e '.microservices.dynamodbTableName = env(DYNAMODB_TABLE_NAME)' -i helm/ui/values.yaml

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        run: |
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          echo "Checking if cluster exists..."
          aws eks describe-cluster --region eu-north-1 --name $CLUSTER_NAME
          echo "Updating kubeconfig..."
          aws eks update-kubeconfig --region eu-north-1 --name $CLUSTER_NAME --alias $CLUSTER_NAME
          echo "Configured kubectl for cluster: $CLUSTER_NAME"

      - name: Configure EKS access
        run: |
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          GITHUB_ROLE_ARN="arn:aws:iam::438465156402:role/dev-vpc-retail-store-github-actions-role"
          echo "Configuring EKS cluster access..."
          
          # Create access entry for GitHub Actions role
          aws eks create-access-entry \
            --cluster-name $CLUSTER_NAME \
            --principal-arn $GITHUB_ROLE_ARN \
            --type STANDARD \
            --region eu-north-1 || echo "Access entry may already exist"
          
          # Associate cluster admin policy
          aws eks associate-access-policy \
            --cluster-name $CLUSTER_NAME \
            --principal-arn $GITHUB_ROLE_ARN \
            --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy \
            --access-scope type=cluster \
            --region eu-north-1 || echo "Policy may already be associated"
          
          echo "Waiting for access to propagate..."
          sleep 30

      - name: Test cluster connection
        run: |
          echo "Testing kubectl connection..."
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespaces

      - name: Create namespace
        run: |
          echo "Creating namespace: $KUBE_NAMESPACE"
          kubectl create namespace $KUBE_NAMESPACE || echo "Namespace may already exist"
          kubectl get namespace $KUBE_NAMESPACE
          echo "Namespace $KUBE_NAMESPACE is ready"

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets-system \
            --create-namespace

      - name: Install AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          # cd ./environments/${{ inputs.environment }}
          # LB_ROLE_ARN=$(terraform output -raw aws_load_balancer_controller_role_arn 2>/dev/null || echo 'arn:aws:iam::438465156402:role/dev-vpc-retail-store-aws-load-balancer-controller')
          # CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo 'dev-vpc-retail-store-eks-cluster')
          LB_ROLE_ARN='arn:aws:iam::438465156402:role/dev-vpc-retail-store-aws-load-balancer-controller'
          CLUSTER_NAME='dev-vpc-retail-store-eks-cluster'
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=$LB_ROLE_ARN
          echo "Installed Load Balancer Controller with role: $LB_ROLE_ARN"

      - name: Setup External Secrets Store
        run: |
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: aws-secrets-store
          spec:
            provider:
              aws:
                service: SecretsManager
                region: eu-north-1
                auth:
                  jwt:
                    serviceAccountRef:
                      name: external-secrets-sa
                      namespace: external-secrets-system
          EOF

      - name: Deploy External Secrets
        run: |
          # cd ./environments/${{ inputs.environment }}
          # POSTGRES_SECRET=$(terraform output -raw postgres_secret_name 2>/dev/null || echo 'dev-vpc-retail-store-postgres-password')
          # MYSQL_SECRET=$(terraform output -raw mysql_secret_name 2>/dev/null || echo 'dev-vpc-retail-store-mysql-password')
          POSTGRES_SECRET='dev-vpc-retail-store-postgres-password'
          MYSQL_SECRET='dev-vpc-retail-store-mysql-password'
          kubectl apply -f - <<EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-postgres-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-postgres-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $POSTGRES_SECRET
          ---
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: app-mysql-db-secret
            namespace: $KUBE_NAMESPACE
          spec:
            refreshInterval: 1h
            secretStoreRef:
              name: aws-secrets-store
              kind: ClusterSecretStore
            target:
              name: app-mysql-db-secret
            data:
            - secretKey: password
              remoteRef:
                key: $MYSQL_SECRET
          EOF
          echo "Deployed External Secrets for: $POSTGRES_SECRET, $MYSQL_SECRET"

      - name: Deploy with Helm
        run: |
          helm upgrade --install cart helm/cart --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install catalog helm/catalog --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install checkout helm/checkout --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install order helm/order --namespace $KUBE_NAMESPACE --create-namespace
          helm upgrade --install ui helm/ui --namespace $KUBE_NAMESPACE --create-namespace